//@version=6
strategy("Long Snap", overlay=true, margin_long=100, margin_short=100, default_qty_type=strategy.percent_of_equity, default_qty_value=10, pyramiding=0, process_orders_on_close=true)

// =================== WVF Settings ===================
wvfGroup = "WVF Settings"
wvfLength = input.int(22, "WVF Lookback Period", group=wvfGroup)
bollingerLength = input.int(20, "Bollinger Length", group=wvfGroup)
bollingerMultiplier = input.float(2.0, "Bollinger Multiplier", step=0.1, group=wvfGroup)
percentileLength = input.int(50, "Percentile Lookback Period", group=wvfGroup)
percentileFactor = input.float(0.85, "Percentile Factor", group=wvfGroup)

triggerWindow = input.int(60, "Trigger Window (bars)", group=wvfGroup)
bodyBuffer = input.int(0, "Body Clearance Buffer (ticks)", minval=0, maxval=5, group=wvfGroup)

// =================== DMI / ADX Filters ===================
dmiGroup = "DMI / ADX Filters"
dmiLength = input.int(14, "DMI Length", group=dmiGroup)
adxSmoothing = input.int(14, "ADX Smoothing", group=dmiGroup)
requirePlusDI = input.bool(true, "Require +DI > -DI", group=dmiGroup)
requireAdxRising = input.bool(true, "Require ADX Rising", group=dmiGroup)
adxRiseLength = input.int(3, "ADX Rising Lookback", minval=1, maxval=20, group=dmiGroup)

useDmiThresholds = input.bool(true, "Enable Level Thresholds", group=dmiGroup)
plusDiThreshold = input.float(20.0, "+DI Threshold", step=0.5, group=dmiGroup)
adxThreshold = input.float(20.0, "ADX Threshold", step=0.5, group=dmiGroup)
minusDiThreshold = input.float(20.0, "-DI Threshold", step=0.5, group=dmiGroup)

// =================== RSI Filters ===================
rsiGroup = "RSI Filters"
useRsi = input.bool(true, "Enable RSI Filtering", group=rsiGroup)
rsiLength = input.int(14, "RSI Length", group=rsiGroup)
rsiSmaLength = input.int(14, "RSI SMA Length", group=rsiGroup)
rsiCrossLookback = input.int(2, "Cross Lookback (bars)", minval=1, group=rsiGroup)
rsiUpperLevel = input.float(70, "Upper Level", group=rsiGroup)
rsiMidLevel = input.float(50, "Middle Level", group=rsiGroup)
rsiLowerLevel = input.float(30, "Lower Level", group=rsiGroup)

allowRsiUpper = input.bool(true, "Allow Upper Zone", group=rsiGroup)
allowRsiMidToUpper = input.bool(false, "Allow Mid-to-Upper Zone", group=rsiGroup)
allowRsiLower = input.bool(false, "Allow Lower Zone", group=rsiGroup)
allowRsiLowerToMid = input.bool(false, "Allow Lower-to-Mid Zone", group=rsiGroup)

// =================== Support & Resistance ===================
srGroup = "Support & Resistance"
useSr = input.bool(true, "Enable S&R Analysis", group=srGroup)
srLength = input.int(15, "S&R Detection Length", minval=5, maxval=50, group=srGroup)
srMargin = input.float(2.0, "S&R Zone Margin", minval=0.1, maxval=10.0, step=0.1, group=srGroup)
srScoreThreshold = input.float(50.0, "Minimum S&R Score", minval=0, maxval=100, step=1, group=srGroup)
showSrZones = input.bool(true, "Show S&R Zones", group=srGroup)

// S&R Zone color inputs (user customizable)
supportColor = input.color(color.new(#089981, 83), "Support Zone Color", group=srGroup)
resistanceColor = input.color(color.new(#f23645, 83), "Resistance Zone Color", group=srGroup)

// =================== Orders ===================
orderGroup = "Orders"
fixedQty = input.float(1, "Fixed Quantity", step=0.1, group=orderGroup)
stopBuffer = input.int(1, "Stop Buffer (ticks)", group=orderGroup)
riskReward = input.float(3.0, "Risk/Reward Ratio", step=0.5, group=orderGroup)

// ---- Optional max-loss sizing ----
useRiskSizing = input.bool(false, "Enable Risk-Based Sizing", group=orderGroup)
maxLossAmount = input.float(530, "Max Loss Per Trade ($)", step=1, group=orderGroup)
maxContracts = input.float(6, "Max Contracts Cap", step=1, group=orderGroup)
roundQty = input.bool(true, "Round to Whole Contracts", group=orderGroup)

// =================== Visual Debugging Markers ===================
visualGroup = "Visual Debugging Markers"
showWvfSpike = input.bool(true, "WVF Spike Markers", group=visualGroup)
showSimpleEntry = input.bool(true, "Simple Entry Markers", group=visualGroup)
showWvfCandidate = input.bool(true, "WVF Candidate Markers", group=visualGroup)
showAcceptedTrades = input.bool(true, "Accepted Trade Markers", group=visualGroup)
showRejectedTrades = input.bool(false, "Rejected Trade Markers", group=visualGroup)
showSrRejected = input.bool(true, "S&R Rejected Markers", group=visualGroup)

visualLinesGroup = "Visual Helper Lines"
showSessionLines = input.bool(true, "Orange Session High Lines", group=visualLinesGroup)

// =================== WVF math (bottom spikes) ===================
highestClose = ta.highest(close, wvfLength)
wvf = (highestClose - low) / math.max(highestClose, 1e-10) * 100.0
standardDev = bollingerMultiplier * ta.stdev(wvf, bollingerLength)
bollingerMid = ta.sma(wvf, bollingerLength)
bollingerUpper = bollingerMid + standardDev
percentileHigh = ta.highest(wvf, percentileLength) * percentileFactor

// WVF red/orange
spikeBar       = (wvf >= bollingerUpper) or (wvf >= percentileHigh)
simpleEntryBar = ((wvf[1] >= bollingerUpper[1]) or (wvf[1] >= percentileHigh[1])) and (wvf < bollingerUpper and wvf < percentileHigh)

// =================== DMI Calculations ===================
[plusDi, minusDi, adx] = ta.dmi(dmiLength, adxSmoothing)
adxRising = ta.rising(adx, adxRiseLength)

plusDiOk  = (not requirePlusDI) or (plusDi > minusDi)
adxOk   = (not requireAdxRising) or adxRising
dmiThresholdsOk = (not useDmiThresholds) or ((plusDi >= plusDiThreshold) and (adx >= adxThreshold) and (minusDi <= minusDiThreshold))
dmiOk = plusDiOk and adxOk and dmiThresholdsOk

// =================== RSI Calculations ===================
rsi = ta.rsi(close, rsiLength)
rsiSma = ta.sma(rsi, rsiSmaLength)
rsiCrossover = ta.crossover(rsi, rsiSma)
barsSinceCross = ta.barssince(rsiCrossover)
recentCross = barsSinceCross <= rsiCrossLookback

aboveUpper = rsi >= rsiUpperLevel
midToUpper = ((rsi >= rsiMidLevel) and (rsi < rsiUpperLevel)) or (recentCross and (rsi < rsiUpperLevel))
belowLower = rsi <= rsiLowerLevel
lowerToMid = (rsi > rsiLowerLevel) and (rsi < rsiMidLevel)

rsiZoneOk = (allowRsiUpper and aboveUpper) or (allowRsiMidToUpper and midToUpper) or (allowRsiLower and belowLower) or (allowRsiLowerToMid and lowerToMid)
rsiOk = (not useRsi) or rsiZoneOk

// Track the active "orange" session
var float sessionClose = na
var float sessionLow   = na
var float sessionHigh  = na
var int   sessionBar   = na
var bool  pending  = false

// Line objects for session visualization
var line sessionHighLine = na

if simpleEntryBar
    // Terminate any existing session lines at current bar (preserve their history)
    if pending and showSessionLines
        if not na(sessionHighLine)
            line.set_x2(sessionHighLine, bar_index - 1)  // Terminate at previous bar
    
    // Reset session tracking
    if pending
        pending := false
    
    // Start new session
    sessionClose := close
    sessionLow   := low
    sessionHigh  := high     // include orange wick
    sessionBar   := bar_index
    pending  := true
    
    // Create new session line (new instance, don't reuse old one)
    if showSessionLines
        sessionHighLine := line.new(bar_index, sessionHigh, bar_index, sessionHigh, color=color.orange, width=2, style=line.style_solid)

// Candidate: first NON-spike bar whose BODY-HIGH clears orange high within window
tick         = syminfo.mintick
bodyBufferTicks = bodyBuffer * tick
barsSinceEntry = na(sessionBar) ? 10e6 : bar_index - sessionBar
bodyHigh     = math.max(open, close)
wvfCandidate = pending and (not spikeBar) and (barsSinceEntry >= 1) and (barsSinceEntry <= triggerWindow) and (bodyHigh > sessionHigh + bodyBufferTicks)

// Reset pending when session expires or is triggered
if pending and (barsSinceEntry > triggerWindow or wvfCandidate)
    if barsSinceEntry > triggerWindow
        // Session expired without trigger - terminate lines at current endpoint
        if showSessionLines
            if not na(sessionHighLine)
                line.set_x2(sessionHighLine, bar_index)  // Finalize at current bar
        
        // Reset session tracking
        sessionClose := na
        sessionLow := na
        sessionHigh := na
        sessionBar := na
        pending := false

// Extend session lines while active
if pending and showSessionLines
    if not na(sessionHighLine)
        line.set_x2(sessionHighLine, bar_index)

// User Defined Types for S&R (matching LuxAlgo structure)
type SnR
    box bx
    bool b    // breakout status
    bool t    // test status  
    bool r    // retest status
    float m   // margin

// Variables for S&R zones (matching LuxAlgo)
var SnR[] resistanceZones = array.new<SnR>()
var SnR[] supportZones = array.new<SnR>()
var SnR lastResistance = SnR.new(box(na), false, false, false, na)
var SnR lastSupport = SnR.new(box(na), false, false, false, na)

// ATR and range calculations
atr = ta.atr(17)
priceRangeHigh = ta.highest(high, srLength)
priceRangeLow = ta.lowest(low, srLength)

// Pivot detection and S&R zone creation (matching LuxAlgo logic)
pivotHigh = ta.pivothigh(high, srLength, srLength)

if not na(pivotHigh) and useSr
    if resistanceZones.size() > 0
        lastResistance := resistanceZones.get(0)
        
        // Calculate zone margin using LuxAlgo formula
        zoneMargin = (priceRangeHigh - priceRangeLow) / priceRangeHigh
        
        // Check if new pivot is outside existing resistance zone
        if pivotHigh < lastResistance.bx.get_bottom() * (1 - lastResistance.m * 0.17 * srMargin) or pivotHigh > lastResistance.bx.get_top() * (1 + lastResistance.m * 0.17 * srMargin)
            // Create new resistance zone (visual display controlled by showSrZones)
            resistanceZones.unshift(SnR.new(box.new(bar_index[srLength], pivotHigh, bar_index, pivotHigh * (1 - zoneMargin * 0.17 * srMargin), border_color=color(na), bgcolor=showSrZones ? resistanceColor : color(na)), false, false, false, zoneMargin))
        else
            // Extend existing zone
            lastResistance.bx.set_right(bar_index)
    else
        // First resistance zone
        zoneMargin = (priceRangeHigh - priceRangeLow) / priceRangeHigh
        resistanceZones.unshift(SnR.new(box.new(bar_index[srLength], pivotHigh, bar_index, pivotHigh * (1 - zoneMargin * 0.17 * srMargin), border_color=color(na), bgcolor=showSrZones ? resistanceColor : color(na)), false, false, false, zoneMargin))

pivotLow = ta.pivotlow(low, srLength, srLength)

if not na(pivotLow) and useSr
    if supportZones.size() > 0
        lastSupport := supportZones.get(0)
        
        // Calculate zone margin using LuxAlgo formula  
        zoneMargin = (priceRangeHigh - priceRangeLow) / priceRangeHigh
        
        // Check if new pivot is outside existing support zone
        if pivotLow < lastSupport.bx.get_bottom() * (1 - lastSupport.m * 0.17 * srMargin) or pivotLow > lastSupport.bx.get_top() * (1 + lastSupport.m * 0.17 * srMargin)
            // Create new support zone (visual display controlled by showSrZones)
            supportZones.unshift(SnR.new(box.new(bar_index[srLength], pivotLow * (1 + zoneMargin * 0.17 * srMargin), bar_index, pivotLow, border_color=color(na), bgcolor=showSrZones ? supportColor : color(na)), false, false, false, zoneMargin))
        else
            // Extend existing zone
            lastSupport.bx.set_right(bar_index)
    else
        // First support zone
        zoneMargin = (priceRangeHigh - priceRangeLow) / priceRangeHigh
        supportZones.unshift(SnR.new(box.new(bar_index[srLength], pivotLow * (1 + zoneMargin * 0.17 * srMargin), bar_index, pivotLow, border_color=color(na), bgcolor=showSrZones ? supportColor : color(na)), false, false, false, zoneMargin))

// Zone flipping logic (resistance becomes support when broken, support becomes resistance when broken)
if resistanceZones.size() > 0 and useSr
    lastResistance := resistanceZones.get(0)
    
    // Check for bullish breakout (resistance becomes support)
    if close[1] > lastResistance.bx.get_top() and not lastResistance.b
        lastResistance.bx.set_right(bar_index[1])
        lastResistance.b := true
        
        // Convert broken resistance to support zone (visual display controlled by showSrZones)
        supportZones.unshift(SnR.new(box.new(bar_index[1], lastResistance.bx.get_top(), bar_index + 1, lastResistance.bx.get_bottom(), border_color=color(na), bgcolor=showSrZones ? supportColor : color(na)), false, false, false, lastResistance.m))
    
    // Extend zone if price is interacting with it
    else if high > lastResistance.bx.get_bottom() * (1 - lastResistance.m * 0.17) and not lastResistance.b
        if high > lastResistance.bx.get_bottom()
            lastResistance.bx.set_right(bar_index)

if supportZones.size() > 0 and useSr  
    lastSupport := supportZones.get(0)
    
    // Check for bearish breakout (support becomes resistance)
    if close[1] < lastSupport.bx.get_bottom() and not lastSupport.b
        lastSupport.bx.set_right(bar_index[1])
        lastSupport.b := true
        
        // Convert broken support to resistance zone (visual display controlled by showSrZones)
        resistanceZones.unshift(SnR.new(box.new(bar_index[1], lastSupport.bx.get_top(), bar_index + 1, lastSupport.bx.get_bottom(), border_color=color(na), bgcolor=showSrZones ? resistanceColor : color(na)), false, false, false, lastSupport.m))
    
    // Extend zone if price is interacting with it
    else if low < lastSupport.bx.get_top() * (1 + lastSupport.m * 0.17) and not lastSupport.b
        if low < lastSupport.bx.get_top()
            lastSupport.bx.set_right(bar_index)

// Function to calculate S&R score for current price
calcSrScore(currentPrice, stopPrice, takeProfitPrice) =>
    score = 50.0  // Base score
    
    if not useSr
        score
    else
        // Check proximity to resistance zones (negative impact)
        resistanceImpact = 0.0
        if resistanceZones.size() > 0
            for i = 0 to resistanceZones.size() - 1
                zone = array.get(resistanceZones, i)
                if not na(zone.bx)
                    resTop = box.get_top(zone.bx)
                    resBottom = box.get_bottom(zone.bx)
                    
                    // If current price or take profit is near/in resistance zone
                    if currentPrice >= resBottom and currentPrice <= resTop
                        resistanceImpact += -30.0  // Heavy penalty for being in resistance
                    else if takeProfitPrice >= resBottom and takeProfitPrice <= resTop
                        resistanceImpact += -20.0  // Penalty if TP hits resistance
                    else if currentPrice > resBottom * 0.99 and currentPrice < resTop * 1.01
                        resistanceImpact += -10.0  // Light penalty for being close
        
        // Check proximity to support zones (positive impact)
        supportImpact = 0.0
        if supportZones.size() > 0
            for i = 0 to supportZones.size() - 1
                zone = array.get(supportZones, i)
                if not na(zone.bx)
                    supTop = box.get_top(zone.bx)
                    supBottom = box.get_bottom(zone.bx)
                    
                    // If current price is in or near support zone
                    if currentPrice >= supBottom and currentPrice <= supTop
                        supportImpact += 20.0  // Bonus for being in support
                    else if currentPrice > supBottom * 0.99 and currentPrice < supTop * 1.01
                        supportImpact += 10.0  // Light bonus for being close
        
        // Calculate headroom to next resistance
        headroomBonus = 0.0
        var float nextResistance = na
        if resistanceZones.size() > 0
            for i = 0 to resistanceZones.size() - 1
                zone = array.get(resistanceZones, i)
                if not na(zone.bx)
                    resBottom = box.get_bottom(zone.bx)
                    if resBottom > currentPrice
                        if na(nextResistance) or resBottom < nextResistance
                            nextResistance := resBottom
        
        if not na(nextResistance)
            distanceToRes = nextResistance - currentPrice
            tradeRange = takeProfitPrice - currentPrice
            if tradeRange > 0
                headroomRatio = distanceToRes / tradeRange
                if headroomRatio > 2.0
                    headroomBonus := 15.0  // Good headroom
                else if headroomRatio > 1.5
                    headroomBonus := 10.0  // Decent headroom
                else if headroomRatio < 1.0
                    headroomBonus := -15.0  // Insufficient headroom
        
        // Combine all factors
        finalScore = score + resistanceImpact + supportImpact + headroomBonus
        math.max(0.0, math.min(100.0, finalScore))  // Clamp between 0-100

// =================== Accept / Reset logic (with optional max-loss sizing) ===================
var bool tradeAccepted  = false
var bool tradeRejected  = false
var bool srRejected = false
tradeAccepted := false
tradeRejected := false
srRejected := false

isCandidate = wvfCandidate

if isCandidate
    if dmiOk and rsiOk
        // Build stop from orange low + buffer
        baseStop = na(sessionLow) ? low : sessionLow
        stopPrice = baseStop - stopBuffer * tick
        riskPoints = close - stopPrice
        takeProfitPrice = close + riskReward * riskPoints
        // Calculate S&R score
        srScore = calcSrScore(close, stopPrice, takeProfitPrice)
        srGateOk = (not useSr) or (srScore >= srScoreThreshold)
        // Declare orderQty variable
        orderQty = 0.0
        if srGateOk
            // ---- sizing ----
            orderQty := fixedQty
            if useRiskSizing
                riskCash = riskPoints * syminfo.pointvalue
                canSize = riskCash > 0
                sized = canSize ? (maxLossAmount / riskCash) : 0.0
                orderQty := roundQty ? math.floor(sized) : sized
                orderQty := math.min(orderQty, maxContracts)
            if (orderQty > 0) and (riskPoints > 0)
                strategy.entry("Long", strategy.long, qty=orderQty)
                strategy.exit("TP/SL", "Long", stop=stopPrice, limit=takeProfitPrice)
                tradeAccepted := true
                // Show S&R score on accepted trades
                if useSr
                    label.new(bar_index, low - atr * 0.5, "S&R Score: " + str.tostring(math.round(srScore)) + "%", style=label.style_label_up, textcolor=color.white, color=srScore >= 70 ? color.green : srScore >= 50 ? color.yellow : color.orange, size=size.tiny)
                // --- ALERT ---
                alertMessage = "Long Snap ENTRY | Qty: " + str.tostring(orderQty) + ", TP: " + str.tostring(takeProfitPrice) + ", SL: " + str.tostring(stopPrice) + ", RR: " + str.tostring(riskReward)
                alert(alertMessage, alert.freq_once_per_bar_close)
            else
                tradeRejected := true
        else
            // Rejected due to S&R score
            srRejected := true
            tradeRejected := true
    else
        tradeRejected := true
    
    // Reset session after trade evaluation (whether accepted or rejected)
    // Terminate session lines at current bar (preserve their history)
    if showSessionLines
        if not na(sessionHighLine)
            line.set_x2(sessionHighLine, bar_index)  // Finalize at current bar
    
    // Reset session tracking
    sessionClose := na
    sessionLow := na
    sessionHigh := na
    sessionBar := na
    pending := false

// Only show yellow when the candidate hasn't been decided yet on this bar
candidatePending = wvfCandidate and not (tradeAccepted or tradeRejected)

plotshape(showWvfSpike and spikeBar, title="WVF Spike (red)", style=shape.circle, location=location.belowbar, color=color.red, size=size.tiny)
plotshape(showSimpleEntry and simpleEntryBar, title="Simple Entry (orange)", style=shape.triangledown, location=location.belowbar, color=color.orange, size=size.tiny)
plotshape(showWvfCandidate and wvfCandidate, title="WVF Candidate (yellow)", style=shape.square, location=location.belowbar, color=color.yellow, size=size.tiny)
plotshape(showAcceptedTrades and tradeAccepted, title="Accepted (filters OK)", style=shape.square, location=location.belowbar, color=color.lime, size=size.tiny)
plotshape(showRejectedTrades and tradeRejected, title="Rejected (filters/sizing)", style=shape.cross, location=location.top, color=color.new(color.purple, 0), size=size.tiny)
plotshape(showSrRejected and srRejected, title="Rejected (S&R score)", style=shape.xcross, location=location.top, color=color.new(color.orange, 0), size=size.small)
