//@version=6


tradeDirGroup = "Trade Direction"
tradeDirection = input.string("Long", "Trade Direction (Long or Short)", options=["Long", "Short"], group=tradeDirGroup)

strategy("Long/Short Snap", overlay=true, margin_long=100, margin_short=100, default_qty_type=strategy.percent_of_equity, default_qty_value=10, pyramiding=0, process_orders_on_close=true)

// =================== WVF Settings ===================
wvfGroup = "WVF Settings"
wvfLength = input.int(22, "WVF Lookback Period", group=wvfGroup)
bollingerLength = input.int(20, "Bollinger Length", group=wvfGroup)
bollingerMultiplier = input.float(2.0, "Bollinger Multiplier", step=0.1, group=wvfGroup)
percentileLength = input.int(50, "Percentile Lookback Period", group=wvfGroup)
showSessionLine = input.bool(true, "Show Session High/Low Line (Long/Short)", group=wvfGroup)
percentileFactor = input.float(0.85, "Percentile Factor", group=wvfGroup)

triggerWindow = input.int(60, "Trigger Window (bars)", group=wvfGroup)
bodyBuffer = input.int(0, "Body Clearance Buffer (ticks)", minval=0, maxval=5, group=wvfGroup)



// =================== DMI / ADX Filters ===================
dmiGroup = "DMI / ADX Filters"
dmiLength = input.int(14, "DMI Length", group=dmiGroup)
adxSmoothing = input.int(14, "ADX Smoothing", group=dmiGroup)
requireDirectionalDI = input.bool(true, "Require Directional DI (trend direction)", group=dmiGroup)
requireDirectionalAdx = input.bool(true, "Require Directional ADX (trend direction)", group=dmiGroup)
adxRiseLength = input.int(3, "ADX Rising Lookback", minval=1, maxval=20, group=dmiGroup)

useDmiThresholds = input.bool(true, "Enable Level Thresholds", group=dmiGroup)
plusDiThreshold = input.float(20.0, "+DI Threshold", step=0.5, group=dmiGroup)
adxThreshold = input.float(20.0, "ADX Threshold", step=0.5, group=dmiGroup)
minusDiThreshold = input.float(20.0, "-DI Threshold", step=0.5, group=dmiGroup)

// =================== RSI Filters ===================
rsiGroup = "RSI Filters"
useRsi = input.bool(true, "Enable RSI Filtering", group=rsiGroup)
rsiLength = input.int(14, "RSI Length", group=rsiGroup)
rsiSmaLength = input.int(14, "RSI SMA Length", group=rsiGroup)
rsiCrossLookback = input.int(2, "Cross Lookback (bars)", minval=1, group=rsiGroup)
rsiUpperLevel = input.float(70, "Upper Level", group=rsiGroup)
rsiMidLevel = input.float(50, "Middle Level", group=rsiGroup)
rsiLowerLevel = input.float(30, "Lower Level", group=rsiGroup)

allowRsiUpper = input.bool(true, "Allow Upper Zone", group=rsiGroup)
allowRsiMidToUpper = input.bool(false, "Allow Mid-to-Upper Zone", group=rsiGroup)
allowRsiLower = input.bool(false, "Allow Lower Zone", group=rsiGroup)
allowRsiLowerToMid = input.bool(false, "Allow Lower-to-Mid Zone", group=rsiGroup)

// =================== Support & Resistance ===================
srGroup = "Support & Resistance"
useSr = input.bool(true, "Enable S&R Analysis", group=srGroup)
srLength = input.int(15, "S&R Detection Length", minval=5, maxval=50, group=srGroup)
srMargin = input.float(2.0, "S&R Zone Margin", minval=0.1, maxval=10.0, step=0.1, group=srGroup)
srScoreThreshold = input.float(50.0, "Minimum S&R Score", minval=0, maxval=100, step=1, group=srGroup)
showSrZones = input.bool(true, "Show S&R Zones", group=srGroup)


supportColor = input.color(color.new(#089981, 83), "Support Zone Color", group=srGroup)
resistanceColor = input.color(color.new(#f23645, 83), "Resistance Zone Color", group=srGroup)


orderGroup = "Orders"
fixedQty = input.float(1, "Fixed Trade Quantity", step=0.1, group=orderGroup)
useRiskSizing = input.bool(false, "Enable Risk-Based Position Sizing", group=orderGroup)
stopBuffer = input.int(1, "Stop Buffer (ticks)", group=orderGroup)
riskReward = input.float(3.0, "Risk/Reward Ratio", step=0.5, group=orderGroup)

// ---- Optional max-loss sizing ----
maxLossAmount = input.float(530, "Max Loss Per Trade ($)", step=1, group=orderGroup)
maxContracts = input.float(6, "Max Contracts Cap", step=1, group=orderGroup)
roundQty = input.bool(true, "Round to Whole Contracts", group=orderGroup)

// =================== Visual Debugging Markers ===================
visualGroup = "Visual Debugging Markers"
showWvfSpike = input.bool(true, "WVF Spike Markers", group=visualGroup)
showSimpleEntry = input.bool(true, "Simple Entry Markers", group=visualGroup)
showWvfCandidate = input.bool(true, "WVF Candidate Markers", group=visualGroup)
showAcceptedTrades = input.bool(true, "Accepted Trade Markers", group=visualGroup)
showRejectedTrades = input.bool(false, "Rejected Trade Markers", group=visualGroup)
showSrRejected = input.bool(true, "S&R Rejected Markers", group=visualGroup)


// =================== WVF math (direction-aware) ===================
// For long: use lows-based WVF (classic Vix Fix)
highestCloseLong = ta.highest(close, wvfLength)
wvfLong = (highestCloseLong - low) / math.max(highestCloseLong, 1e-10) * 100.0
standardDevLong = bollingerMultiplier * ta.stdev(wvfLong, bollingerLength)
bollingerMidLong = ta.sma(wvfLong, bollingerLength)
bollingerUpperLong = bollingerMidLong + standardDevLong
percentileHighLong = ta.highest(wvfLong, percentileLength) * percentileFactor

// For short: use highs-based WVF (euphoria spikes)
lowestCloseShort = ta.lowest(close, wvfLength)
wvfShort = ((lowestCloseShort - high) / math.max(lowestCloseShort, 1e-10)) * 100.0
standardDevShort = bollingerMultiplier * ta.stdev(wvfShort, bollingerLength)
bollingerMidShort = ta.sma(wvfShort, bollingerLength)
bollingerLowerShort = bollingerMidShort - standardDevShort
percentileLowShort = ta.lowest(wvfShort, percentileLength) * percentileFactor

// WVF spike and simple entry logic, direction-aware
spikeBarLong = (wvfLong >= bollingerUpperLong) or (wvfLong >= percentileHighLong)
simpleEntryBarLong = ((wvfLong[1] >= bollingerUpperLong[1]) or (wvfLong[1] >= percentileHighLong[1])) and (wvfLong < bollingerUpperLong and wvfLong < percentileHighLong)

spikeBarShort = (wvfShort <= bollingerLowerShort) or (wvfShort <= percentileLowShort)
simpleEntryBarShort = ((wvfShort[1] <= bollingerLowerShort[1]) or (wvfShort[1] <= percentileLowShort[1])) and (wvfShort > bollingerLowerShort and wvfShort > percentileLowShort)

// Unified direction-aware variables for use in session/candidate logic
spikeBar = tradeDirection == "Long" ? spikeBarLong : spikeBarShort
simpleEntryBar = tradeDirection == "Long" ? simpleEntryBarLong : simpleEntryBarShort

// =================== DMI Calculations (directional) ===================
[plusDi, minusDi, adx] = ta.dmi(dmiLength, adxSmoothing)
adxRising = ta.rising(adx, adxRiseLength)
adxFalling = ta.falling(adx, adxRiseLength)

// DMI/ADX logic: invert for shorts
plusDiOkLong  = (not requireDirectionalDI) or (plusDi > minusDi)
plusDiOkShort = (not requireDirectionalDI) or (minusDi > plusDi)
adxOkLong   = (not requireDirectionalAdx) or adxRising
adxOkShort  = (not requireDirectionalAdx) or adxFalling
dmiThresholdsOkLong = (not useDmiThresholds) or ((plusDi >= plusDiThreshold) and (adx >= adxThreshold) and (minusDi <= minusDiThreshold))
dmiThresholdsOkShort = (not useDmiThresholds) or ((minusDi >= plusDiThreshold) and (adx >= adxThreshold) and (plusDi <= minusDiThreshold))
dmiOkLong = plusDiOkLong and adxOkLong and dmiThresholdsOkLong
dmiOkShort = plusDiOkShort and adxOkShort and dmiThresholdsOkShort

// =================== RSI Calculations (directional) ===================
rsi = ta.rsi(close, rsiLength)
rsiSma = ta.sma(rsi, rsiSmaLength)
rsiCrossUp = ta.crossover(rsi, rsiSma)
rsiCrossDown = ta.crossunder(rsi, rsiSma)
barsSinceCrossUp = ta.barssince(rsiCrossUp)
barsSinceCrossDown = ta.barssince(rsiCrossDown)
recentCrossUp = barsSinceCrossUp <= rsiCrossLookback
recentCrossDown = barsSinceCrossDown <= rsiCrossLookback

// Long zones (original)
aboveUpper = rsi >= rsiUpperLevel
midToUpper = ((rsi >= rsiMidLevel) and (rsi < rsiUpperLevel)) or (recentCrossUp and (rsi < rsiUpperLevel))
belowLower = rsi <= rsiLowerLevel
lowerToMid = (rsi > rsiLowerLevel) and (rsi < rsiMidLevel)

// Short zones (mirrored)
belowLowerShort = rsi <= rsiLowerLevel
midToLowerShort = ((rsi > rsiLowerLevel) and (rsi <= rsiMidLevel)) or (recentCrossDown and (rsi > rsiLowerLevel))
aboveUpperShort = rsi >= rsiUpperLevel
upperToMidShort = (rsi < rsiUpperLevel) and (rsi >= rsiMidLevel)

// Zone gating for long/short
rsiZoneOkLong = (allowRsiUpper and aboveUpper) or (allowRsiMidToUpper and midToUpper) or (allowRsiLower and belowLower) or (allowRsiLowerToMid and lowerToMid)
rsiZoneOkShort = (allowRsiLower and belowLowerShort) or (allowRsiLowerToMid and midToLowerShort) or (allowRsiUpper and aboveUpperShort) or (allowRsiMidToUpper and upperToMidShort)
rsiOkLong = (not useRsi) or rsiZoneOkLong
rsiOkShort = (not useRsi) or rsiZoneOkShort


// === Session and trigger logic for both long and short ===
var float sessionCloseLong = na
var float sessionLowLong   = na
var float sessionHighLong  = na
var int   sessionBarLong   = na
var bool  pendingLong  = false
var line sessionHighLineLong = na

var float sessionCloseShort = na
var float sessionLowShort   = na
var float sessionHighShort  = na
var int   sessionBarShort   = na
var bool  pendingShort  = false
var line sessionLowLineShort = na

// --- Long session logic (original) ---
if tradeDirection == "Long" and simpleEntryBarLong
    if pendingLong and showSessionLine
        if not na(sessionHighLineLong)
            line.set_x2(sessionHighLineLong, bar_index - 1)
    if pendingLong
        pendingLong := false
    sessionCloseLong := close
    sessionLowLong   := low
    sessionHighLong  := high
    sessionBarLong   := bar_index
    pendingLong  := true
    if showSessionLine
        sessionHighLineLong := line.new(bar_index, sessionHighLong, bar_index, sessionHighLong, color=color.orange, width=2, style=line.style_solid)

tick = syminfo.mintick
bodyBufferTicks = bodyBuffer * tick
barsSinceEntryLong = na(sessionBarLong) ? 10e6 : bar_index - sessionBarLong
bodyHigh = math.max(open, close)
wvfCandidateLong = pendingLong and (not spikeBarLong) and (barsSinceEntryLong >= 1) and (barsSinceEntryLong <= triggerWindow) and (bodyHigh > sessionHighLong + bodyBufferTicks)

if tradeDirection == "Long" and pendingLong and (barsSinceEntryLong > triggerWindow or wvfCandidateLong)
    if barsSinceEntryLong > triggerWindow
        if showSessionLine
            if not na(sessionHighLineLong)
                line.set_x2(sessionHighLineLong, bar_index)
        sessionCloseLong := na
        sessionLowLong := na
        sessionHighLong := na
        sessionBarLong := na
        pendingLong := false
if tradeDirection == "Long" and pendingLong and showSessionLine
    if not na(sessionHighLineLong)
        line.set_x2(sessionHighLineLong, bar_index)

// --- Short session logic (mirrored) ---
if tradeDirection == "Short" and simpleEntryBarShort
    if pendingShort and showSessionLine
        if not na(sessionLowLineShort)
            line.set_x2(sessionLowLineShort, bar_index - 1)
    if pendingShort
        pendingShort := false
    sessionCloseShort := close
    sessionLowShort   := low
    sessionHighShort  := high
    sessionBarShort   := bar_index
    pendingShort  := true
    if showSessionLine
        sessionLowLineShort := line.new(bar_index, sessionLowShort, bar_index, sessionLowShort, color=color.aqua, width=2, style=line.style_solid)

barsSinceEntryShort = na(sessionBarShort) ? 10e6 : bar_index - sessionBarShort
bodyLow = math.min(open, close)
wvfCandidateShort = pendingShort and (not spikeBarShort) and (barsSinceEntryShort >= 1) and (barsSinceEntryShort <= triggerWindow) and (bodyLow < sessionLowShort - bodyBufferTicks)

if tradeDirection == "Short" and pendingShort and (barsSinceEntryShort > triggerWindow or wvfCandidateShort)
    if barsSinceEntryShort > triggerWindow
        if showSessionLine
            if not na(sessionLowLineShort)
                line.set_x2(sessionLowLineShort, bar_index)
        sessionCloseShort := na
        sessionLowShort := na
        sessionHighShort := na
        sessionBarShort := na
        pendingShort := false
if tradeDirection == "Short" and pendingShort and showSessionLine
    if not na(sessionLowLineShort)
        line.set_x2(sessionLowLineShort, bar_index)

// User Defined Types for S&R (matching LuxAlgo structure)
type SnR
    box bx
    bool b    // breakout status
    bool t    // test status  
    bool r    // retest status
    float m   // margin

// Variables for S&R zones (matching LuxAlgo)
var SnR[] resistanceZones = array.new<SnR>()
var SnR[] supportZones = array.new<SnR>()
var SnR lastResistance = SnR.new(box(na), false, false, false, na)
var SnR lastSupport = SnR.new(box(na), false, false, false, na)

// ATR and range calculations
atr = ta.atr(17)
priceRangeHigh = ta.highest(high, srLength)
priceRangeLow = ta.lowest(low, srLength)

// Pivot detection and S&R zone creation (matching LuxAlgo logic)
pivotHigh = ta.pivothigh(high, srLength, srLength)

if not na(pivotHigh) and useSr
    if resistanceZones.size() > 0
        lastResistance := resistanceZones.get(0)
        
        // Calculate zone margin using LuxAlgo formula
        zoneMargin = (priceRangeHigh - priceRangeLow) / priceRangeHigh
        
        // Check if new pivot is outside existing resistance zone
        if pivotHigh < lastResistance.bx.get_bottom() * (1 - lastResistance.m * 0.17 * srMargin) or pivotHigh > lastResistance.bx.get_top() * (1 + lastResistance.m * 0.17 * srMargin)
            // Create new resistance zone (visual display controlled by showSrZones)
            resistanceZones.unshift(SnR.new(box.new(bar_index[srLength], pivotHigh, bar_index, pivotHigh * (1 - zoneMargin * 0.17 * srMargin), border_color=color(na), bgcolor=showSrZones ? resistanceColor : color(na)), false, false, false, zoneMargin))
        else
            // Extend existing zone
            lastResistance.bx.set_right(bar_index)
    else
        // First resistance zone
        zoneMargin = (priceRangeHigh - priceRangeLow) / priceRangeHigh
        resistanceZones.unshift(SnR.new(box.new(bar_index[srLength], pivotHigh, bar_index, pivotHigh * (1 - zoneMargin * 0.17 * srMargin), border_color=color(na), bgcolor=showSrZones ? resistanceColor : color(na)), false, false, false, zoneMargin))

pivotLow = ta.pivotlow(low, srLength, srLength)

if not na(pivotLow) and useSr
    if supportZones.size() > 0
        lastSupport := supportZones.get(0)
        
        // Calculate zone margin using LuxAlgo formula  
        zoneMargin = (priceRangeHigh - priceRangeLow) / priceRangeHigh
        
        // Check if new pivot is outside existing support zone
        if pivotLow < lastSupport.bx.get_bottom() * (1 - lastSupport.m * 0.17 * srMargin) or pivotLow > lastSupport.bx.get_top() * (1 + lastSupport.m * 0.17 * srMargin)
            // Create new support zone (visual display controlled by showSrZones)
            supportZones.unshift(SnR.new(box.new(bar_index[srLength], pivotLow * (1 + zoneMargin * 0.17 * srMargin), bar_index, pivotLow, border_color=color(na), bgcolor=showSrZones ? supportColor : color(na)), false, false, false, zoneMargin))
        else
            // Extend existing zone
            lastSupport.bx.set_right(bar_index)
    else
        // First support zone
        zoneMargin = (priceRangeHigh - priceRangeLow) / priceRangeHigh
        supportZones.unshift(SnR.new(box.new(bar_index[srLength], pivotLow * (1 + zoneMargin * 0.17 * srMargin), bar_index, pivotLow, border_color=color(na), bgcolor=showSrZones ? supportColor : color(na)), false, false, false, zoneMargin))

// Zone flipping logic (resistance becomes support when broken, support becomes resistance when broken)
if resistanceZones.size() > 0 and useSr
    lastResistance := resistanceZones.get(0)
    
    // Check for bullish breakout (resistance becomes support)
    if close[1] > lastResistance.bx.get_top() and not lastResistance.b
        lastResistance.bx.set_right(bar_index[1])
        lastResistance.b := true
        
        // Convert broken resistance to support zone (visual display controlled by showSrZones)
        supportZones.unshift(SnR.new(box.new(bar_index[1], lastResistance.bx.get_top(), bar_index + 1, lastResistance.bx.get_bottom(), border_color=color(na), bgcolor=showSrZones ? supportColor : color(na)), false, false, false, lastResistance.m))
    
    // Extend zone if price is interacting with it
    else if high > lastResistance.bx.get_bottom() * (1 - lastResistance.m * 0.17) and not lastResistance.b
        if high > lastResistance.bx.get_bottom()
            lastResistance.bx.set_right(bar_index)

if supportZones.size() > 0 and useSr  
    lastSupport := supportZones.get(0)
    
    // Check for bearish breakout (support becomes resistance)
    if close[1] < lastSupport.bx.get_bottom() and not lastSupport.b
        lastSupport.bx.set_right(bar_index[1])
        lastSupport.b := true
        
        // Convert broken support to resistance zone (visual display controlled by showSrZones)
        resistanceZones.unshift(SnR.new(box.new(bar_index[1], lastSupport.bx.get_top(), bar_index + 1, lastSupport.bx.get_bottom(), border_color=color(na), bgcolor=showSrZones ? resistanceColor : color(na)), false, false, false, lastSupport.m))
    
    // Extend zone if price is interacting with it
    else if low < lastSupport.bx.get_top() * (1 + lastSupport.m * 0.17) and not lastSupport.b
        if low < lastSupport.bx.get_top()
            lastSupport.bx.set_right(bar_index)

// Function to calculate S&R score for current price

calcSrScore(currentPrice, stopPrice, takeProfitPrice) =>
    score = 50.0  // Base score
    if not useSr
        score
    else
        var float resistanceImpact = 0.0
        var float supportImpact = 0.0
        var float headroomBonus = 0.0
        // Directional S&R logic
        if tradeDirection == "Long"
            // --- Long logic (original) ---
            if resistanceZones.size() > 0
                for i = 0 to resistanceZones.size() - 1
                    zone = array.get(resistanceZones, i)
                    if not na(zone.bx)
                        resTop = box.get_top(zone.bx)
                        resBottom = box.get_bottom(zone.bx)
                        if currentPrice >= resBottom and currentPrice <= resTop
                            resistanceImpact += -30.0
                        else if takeProfitPrice >= resBottom and takeProfitPrice <= resTop
                            resistanceImpact += -20.0
                        else if currentPrice > resBottom * 0.99 and currentPrice < resTop * 1.01
                            resistanceImpact += -10.0
            if supportZones.size() > 0
                for i = 0 to supportZones.size() - 1
                    zone = array.get(supportZones, i)
                    if not na(zone.bx)
                        supTop = box.get_top(zone.bx)
                        supBottom = box.get_bottom(zone.bx)
                        if currentPrice >= supBottom and currentPrice <= supTop
                            supportImpact += 20.0
                        else if currentPrice > supBottom * 0.99 and currentPrice < supTop * 1.01
                            supportImpact += 10.0
            // Headroom to next resistance above
            var float nextResistance = na
            if resistanceZones.size() > 0
                for i = 0 to resistanceZones.size() - 1
                    zone = array.get(resistanceZones, i)
                    if not na(zone.bx)
                        resBottom = box.get_bottom(zone.bx)
                        if resBottom > currentPrice
                            if na(nextResistance) or resBottom < nextResistance
                                nextResistance := resBottom
            if not na(nextResistance)
                distanceToRes = nextResistance - currentPrice
                tradeRange = takeProfitPrice - currentPrice
                if tradeRange > 0
                    headroomRatio = distanceToRes / tradeRange
                    if headroomRatio > 2.0
                        headroomBonus := 15.0
                    else if headroomRatio > 1.5
                        headroomBonus := 10.0
                    else if headroomRatio < 1.0
                        headroomBonus := -15.0
        else
            // --- Short logic (mirrored) ---
            if supportZones.size() > 0
                for i = 0 to supportZones.size() - 1
                    zone = array.get(supportZones, i)
                    if not na(zone.bx)
                        supTop = box.get_top(zone.bx)
                        supBottom = box.get_bottom(zone.bx)
                        if currentPrice >= supBottom and currentPrice <= supTop
                            supportImpact += -30.0  // Penalty for being in support (now negative)
                        else if takeProfitPrice >= supBottom and takeProfitPrice <= supTop
                            supportImpact += -20.0  // Penalty if TP hits support
                        else if currentPrice > supBottom * 0.99 and currentPrice < supTop * 1.01
                            supportImpact += -10.0  // Penalty for being close
            if resistanceZones.size() > 0
                for i = 0 to resistanceZones.size() - 1
                    zone = array.get(resistanceZones, i)
                    if not na(zone.bx)
                        resTop = box.get_top(zone.bx)
                        resBottom = box.get_bottom(zone.bx)
                        if currentPrice >= resBottom and currentPrice <= resTop
                            resistanceImpact += 20.0  // Bonus for being in resistance
                        else if currentPrice > resBottom * 0.99 and currentPrice < resTop * 1.01
                            resistanceImpact += 10.0  // Bonus for being close
            // Headroom to next support below
            var float nextSupport = na
            if supportZones.size() > 0
                for i = 0 to supportZones.size() - 1
                    zone = array.get(supportZones, i)
                    if not na(zone.bx)
                        supTop = box.get_top(zone.bx)
                        if supTop < currentPrice
                            if na(nextSupport) or supTop > nextSupport
                                nextSupport := supTop
            if not na(nextSupport)
                distanceToSup = currentPrice - nextSupport
                tradeRange = currentPrice - takeProfitPrice
                if tradeRange > 0
                    headroomRatio = distanceToSup / tradeRange
                    if headroomRatio > 2.0
                        headroomBonus := 15.0
                    else if headroomRatio > 1.5
                        headroomBonus := 10.0
                    else if headroomRatio < 1.0
                        headroomBonus := -15.0
        finalScore = score + resistanceImpact + supportImpact + headroomBonus
        math.max(0.0, math.min(100.0, finalScore))

// =================== Accept / Reset logic (with optional max-loss sizing) ===================
var bool tradeAccepted  = false
var bool tradeRejected  = false
var bool srRejected = false
tradeAccepted := false
tradeRejected := false
srRejected := false




// --- Session Gating: Only allow entries between 6PM ET Sunday and 4PM ET Friday, close all at 4PM ET ---
// Pine Script uses UTC. 6PM ET = 23:00 UTC, 4PM ET = 21:00 UTC (approx, not handling DST here)
// TradingView's 'timestamp' and 'hour', 'minute', 'dayofweek' are in exchange time, so use 'hour' and 'dayofweek'.

// Helper: is it between 6PM ET (23:00 UTC) and 4PM ET (21:00 UTC) for the day?
withinDailySession = (hour >= 18 or hour < 16)

// Helper: is it between Sunday 6PM ET and Friday 4PM ET?
// Pine Script dayofweek: Sunday=1, Monday=2, ..., Friday=6, Saturday=7
isSessionOpen = (dayofweek == dayofweek.sunday and hour >= 18) or (dayofweek > dayofweek.sunday and dayofweek < dayofweek.friday) or (dayofweek == dayofweek.friday and hour < 16)

// Helper: is it the daily close bar (4PM ET)?
isDailyCloseBar = (hour == 16 and minute == 0)

// --- Force close all trades at 4PM ET (daily close) ---
if isDailyCloseBar
    strategy.close_all(comment="Daily Close 4PM ET")

// Only show yellow when the candidate hasn't been decided yet on this bar
candidatePending = (wvfCandidateLong or wvfCandidateShort) and not (tradeAccepted or tradeRejected)

// --- Candidate and gating logic for long ---
// Only allow new entries if session is open
isCandidateLong = wvfCandidateLong and isSessionOpen
dmiOkLongActive = dmiOkLong
rsiOkLongActive = rsiOkLong

if tradeDirection == "Long" and isCandidateLong
    if dmiOkLongActive and rsiOkLongActive
        orderQty = 0.0
        var float stopPrice = na
        var float takeProfitPrice = na
        var float riskPoints = na
        var float baseStop = na
        var float baseTake = na
        var float srScore = na
        baseStop := na(sessionLowLong) ? low : sessionLowLong
        stopPrice := baseStop - stopBuffer * tick
        riskPoints := close - stopPrice
        takeProfitPrice := close + riskReward * riskPoints
        srScore := calcSrScore(close, stopPrice, takeProfitPrice)
        srGateOk = (not useSr) or (srScore >= srScoreThreshold)
        if srGateOk
            orderQty := fixedQty
            if useRiskSizing
                riskCash = riskPoints * syminfo.pointvalue
                canSize = riskCash > 0
                sized = canSize ? (maxLossAmount / riskCash) : 0.0
                orderQty := roundQty ? math.floor(sized) : sized
                orderQty := math.min(orderQty, maxContracts)
            if (orderQty > 0) and (riskPoints > 0)
                strategy.entry("Long", strategy.long, qty=orderQty)
                strategy.exit("TP/SL", "Long", stop=stopPrice, limit=takeProfitPrice)
                tradeAccepted := true
                if useSr
                    label.new(bar_index, low - atr * 0.5, "S&R Score: " + str.tostring(math.round(srScore)) + "%", style=label.style_label_up, textcolor=color.white, color=srScore >= 70 ? color.green : srScore >= 50 ? color.yellow : color.orange, size=size.tiny)
                alertMessage = "Long Snap ENTRY | Qty: " + str.tostring(orderQty) + ", TP: " + str.tostring(takeProfitPrice) + ", SL: " + str.tostring(stopPrice) + ", RR: " + str.tostring(riskReward)
                alert(alertMessage, alert.freq_once_per_bar_close)
            else
                tradeRejected := true
        else
            srRejected := true
            tradeRejected := true
    else
        tradeRejected := true
    if showSessionLine
        if not na(sessionHighLineLong)
            line.set_x2(sessionHighLineLong, bar_index)
    sessionCloseLong := na
    sessionLowLong := na
    sessionHighLong := na
    sessionBarLong := na
    pendingLong := false

// --- Candidate and gating logic for short ---
// Only allow new entries if session is open
isCandidateShort = wvfCandidateShort and isSessionOpen
dmiOkShortActive = dmiOkShort
rsiOkShortActive = rsiOkShort

if tradeDirection == "Short" and isCandidateShort
    if dmiOkShortActive and rsiOkShortActive
        orderQty = 0.0
        var float stopPrice = na
        var float takeProfitPrice = na
        var float riskPoints = na
        var float baseStop = na
        var float baseTake = na
        var float srScore = na
        baseStop := na(sessionHighShort) ? high : sessionHighShort
        stopPrice := baseStop + stopBuffer * tick
        riskPoints := stopPrice - close
        takeProfitPrice := close - riskReward * riskPoints
        srScore := calcSrScore(close, stopPrice, takeProfitPrice)
        srGateOk = (not useSr) or (srScore >= srScoreThreshold)
        if srGateOk
            orderQty := fixedQty
            if useRiskSizing
                riskCash = riskPoints * syminfo.pointvalue
                canSize = riskCash > 0
                sized = canSize ? (maxLossAmount / riskCash) : 0.0
                orderQty := roundQty ? math.floor(sized) : sized
                orderQty := math.min(orderQty, maxContracts)
            if (orderQty > 0) and (riskPoints > 0)
                strategy.entry("Short", strategy.short, qty=orderQty)
                strategy.exit("TP/SL", "Short", stop=stopPrice, limit=takeProfitPrice)
                tradeAccepted := true
                if useSr
                    label.new(bar_index, high + atr * 0.5, "S&R Score: " + str.tostring(math.round(srScore)) + "%", style=label.style_label_down, textcolor=color.white, color=srScore >= 70 ? color.green : srScore >= 50 ? color.yellow : color.orange, size=size.tiny)
                alertMessage = "Short Snap ENTRY | Qty: " + str.tostring(orderQty) + ", TP: " + str.tostring(takeProfitPrice) + ", SL: " + str.tostring(stopPrice) + ", RR: " + str.tostring(riskReward)
                alert(alertMessage, alert.freq_once_per_bar_close)
            else
                tradeRejected := true
        else
            srRejected := true
            tradeRejected := true
    else
        tradeRejected := true
    if showSessionLine
        if not na(sessionLowLineShort)
            line.set_x2(sessionLowLineShort, bar_index)
    sessionCloseShort := na
    sessionLowShort := na
    sessionHighShort := na
    sessionBarShort := na
    pendingShort := false


// --- Debugging Markers: Long (belowbar) and Short (abovebar) ---
plotshape(tradeDirection == "Long" and showWvfSpike and spikeBarLong, title="WVF Spike Long (red)", style=shape.circle, location=location.belowbar, color=color.red, size=size.tiny)
plotshape(tradeDirection == "Short" and showWvfSpike and spikeBarShort, title="WVF Spike Short (red)", style=shape.circle, location=location.abovebar, color=color.red, size=size.tiny)
plotshape(tradeDirection == "Long" and showSimpleEntry and simpleEntryBarLong, title="Simple Entry Long (orange)", style=shape.triangledown, location=location.belowbar, color=color.orange, size=size.tiny)
plotshape(tradeDirection == "Short" and showSimpleEntry and simpleEntryBarShort, title="Simple Entry Short (orange)", style=shape.triangleup, location=location.abovebar, color=color.orange, size=size.tiny)
plotshape(tradeDirection == "Long" and showWvfCandidate and wvfCandidateLong, title="WVF Candidate Long (yellow)", style=shape.square, location=location.belowbar, color=color.yellow, size=size.tiny)
plotshape(tradeDirection == "Short" and showWvfCandidate and wvfCandidateShort, title="WVF Candidate Short (yellow)", style=shape.square, location=location.abovebar, color=color.yellow, size=size.tiny)
plotshape(tradeDirection == "Long" and showAcceptedTrades and tradeAccepted and isCandidateLong, title="Accepted Long (filters OK)", style=shape.square, location=location.belowbar, color=color.lime, size=size.tiny)
plotshape(tradeDirection == "Short" and showAcceptedTrades and tradeAccepted and isCandidateShort, title="Accepted Short (filters OK)", style=shape.square, location=location.abovebar, color=color.lime, size=size.tiny)
plotshape(tradeDirection == "Long" and showRejectedTrades and tradeRejected and isCandidateLong, title="Rejected Long (filters/sizing)", style=shape.cross, location=location.belowbar, color=color.new(color.purple, 0), size=size.tiny)
plotshape(tradeDirection == "Short" and showRejectedTrades and tradeRejected and isCandidateShort, title="Rejected Short (filters/sizing)", style=shape.cross, location=location.abovebar, color=color.new(color.blue, 0), size=size.tiny)
plotshape(tradeDirection == "Long" and showSrRejected and srRejected and isCandidateLong, title="Rejected Long (S&R score)", style=shape.xcross, location=location.belowbar, color=color.new(color.orange, 0), size=size.small)
plotshape(tradeDirection == "Short" and showSrRejected and srRejected and isCandidateShort, title="Rejected Short (S&R score)", style=shape.xcross, location=location.abovebar, color=color.new(color.aqua, 0), size=size.small)
